
AVRASM ver. 2.1.12  core\bldc.asm Tue Nov 08 12:58:41 2011

[builtin](2): Including file 'C:\Program Files (x86)\AvrAssembler2\AppNotes\m8def.inc'
[builtin](3): Including file 'core\..\input\pwm_rc_200.inc'
[builtin](4): Including file 'core\..\hw\Mystery20A.inc'
core\..\hw\Mystery20A.inc(1): Including file 'core\common.inc'
core\bldc.asm(22): Including file 'core\ppm_light.inc'
core\bldc.asm(1355): Including file 'core\str_zc_filter.inc'
                 
                 ;**** **** **** **** ****
                 
                 ;***** Created: 2007-02-28 07:32 ******* Source: ATmega8.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m8def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega8
                 ;* Date              : 2007-02-28
                 ;* Version           : 2.24
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega8
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M8DEF_INC_
                 #define _M8DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega8
                 #pragma AVRPART ADMIN PART_NAME ATmega8
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x07
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCL	= 0x04
                 .equ	ADCH	= 0x05
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 
                 ; TCCR0 - Timer/Counter0 Control Register
                 .equ	CS00	= 0	; Clock Select0 bit 0
                 .equ	CS01	= 1	; Clock Select0 bit 1
                 .equ	CS02	= 2	; Clock Select0 bit 2
                 
                 ; TCNT0 - Timer Counter 0
                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Waveform Genration Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EEWEE	= EEMWE	; For compatibility
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PUD	= 2	; Pull-up Disable
                 .equ	ADHSM	= 4	; ADC High Speed Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADFR	= 5	; ADC  Free Running Select
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	WTDON	= 6	; Enable watchdog
                 .equ	RSTDISBL	= 7	; Disable reset
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x045f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _M8DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 
                 
                 #define POWER_RANGE 200
                 #define MIN_RC_PULS 1100
                 
                 ; falling->rising intervals
                 #define MAX_INT_FR  25000
                 #define MIN_INT_FR  15000
                 
                 ; rising->falling intervals
                 #define MAX_INT_RF  2200
                 #define MIN_INT_RF  800
                 
                 .macro EvaluatePWC
                                 sbrs    flags1, RC_PULS_UPDATED
                                 ret
                                 movw    temp1:temp2, new_rcpuls_l:new_rcpuls_h  
                                 cbr     flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
                                 subi    temp1, low  (MIN_RC_PULS*CLK_SCALE)
                                 sbci    temp2, high (MIN_RC_PULS*CLK_SCALE)
                                 brcc    eval_rc_p00
                                 clr     temp1
                                 clr     temp2
                 eval_rc_p00:    lsr     temp2
                                 ror     temp1
                                 lsr     temp2
                                 ror     temp1
                 .if CLK_SCALE==2
                                 lsr     temp2   ; actual 0->400
                                 ror     temp1
                 .endif
                                 cpi     temp1, POWER_RANGE - 1
                                 brcs    eval_rc_p10
                                 ldi     temp1, POWER_RANGE - 1
                 eval_rc_p10:    
                                 mov     ZH, temp1
                                 ret
                 
                 .endmacro
                 ;
                 
                 
                   cbi     ADCSRA, ADEN          ; disable ADC
                   in      temp1, SFIOR
                   sbr     temp1, (1<<ACME)      ; switch to comparator multiplexed
                   out     SFIOR, temp1
                 .endmacro  
                 
                 .macro ACNormal
                    cbr  temp1, (1<<ACME)        ; set to AN1
                    out  SFIOR, temp1
                    sbi  ADCSRA, ADEN            ; enable ADC
                 .endmacro  
                 
                 .macro ACChannel 
                    ldi   temp1, @0              
                    out   ADMUX, temp1
                 .endmacro  
                    
                 #define RPM_TO_COMM_TIME(x) (1000000 * 10 / x)
                 #define PWR_PCT_TO_VAL(x)   (x*POWER_RANGE/100)
                 
                 #define PWR_CURVE_POINT(pt, rpm, pwr) \
                 .equ    RPM_RUN_RANGE_ ## pt  = rpm\
                 .equ    PCT_PWR_MAX_RPM_ ## pt = pwr
                 
                 
                 /*
                 .macro PwmCSEnter
                                 ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
                                 out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
                                 nop
                 .endm
                 
                 .macro PwmCSLeave
                                 ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
                                 out     TIMSK, temp1 
                 .endm
                 */
                 
                 .macro PwmCSEnter
                                 cli
                 .endm
                 
                 .macro PwmCSLeave
                                 sei
                 .endm
                 
                 .equ    T1STOP           = 0x00
                 .equ    T1CK8            = 0x02
                 
                 #define Typ "Mystery 20"
                 
                 
                 ;**** **** **** **** ****
                 ; PORT  definitions
                 ;**** **** **** **** ****
                 
                 ;*********************
                 ; PORT D 
                 ;*********************  
                 ;#define                7     ;
                 #define c_comp          6     ;i common comparator input (AIN0)
                 #define AnFET           5     ;o
                 #define ApFET           4     ;o
                 ;#define                3     ;
                 #define rcp_in          2     ;i r/c pulse input
                 ;#define                1     ;
                 ;#define                0     ;
                 
                 
                 #define INIT_PD         0
                 #define DIR_PD          (1<<ApFET)+(1<<AnFET)
                 #define BRAKE_PD        (1<<AnFET)
                 
                 
                 ;*********************
                 ; ADC definitions
                 ;*********************
                 
                 #define mux_c           0     ; ADC0
                 #define mux_a           6     ; ADC6
                 #define mux_b           7     ; ADC7
                 #define ACCU_MUX        2     ; ADC2 voltage control input 
                 
                 ;*********************
                 ; PORT C definitions *
                 ;*********************
                 #define AnRef           1
                 #define CpFET           3
                 #define BnFET           4
                 #define BpFET           5  
                 
                 
                 #define INIT_PC         (1<<AnRef)
                 #define DIR_PC          (1<<AnRef)+(1<<CpFET)+(1<<BnFET)+(1<<BpFET)
                 #define BRAKE_PC        (1<<BnFET)
                 
                 
                 ;*********************
                 ; PORT B definitions *
                 ;*********************
                 ;#define                7     
                 ;#define                6     
                 #define DbgLED          5;    (sck stk200 interface) 
                 ;#define                4     (miso stk200 interface)
                 ;#define                3     (mosi stk200 interface) 
                 ;#define                2     
                 ;#define                1     
                 #define CnFET           0
                 
                 #define INIT_PB         0
                 #define DIR_PB          (1<<CnFET)+(1<<DbgLED)
                 #define BRAKE_PB        (1<<CnFET)
                 
                 
                 #define DbgLEDOn        sbi     PORTB,5
                 #define DbgLEDOff       cbi     PORTB,5
                 
                 
                 ;*********************
                 ; FET Control        *
                 ;*********************
                 #define ApFET_on        sbi     PORTD,4
                 #define ApFET_off       cbi     PORTD,4
                 #define AnFET_on        sbi     PORTD,5
                 #define AnFET_off       cbi     PORTD,5
                 
                 #define BpFET_on        sbi     PORTC,5
                 #define BpFET_off       cbi     PORTC,5
                 #define BnFET_on        sbi     PORTC,4
                 #define BnFET_off       cbi     PORTC,4
                 
                 #define CpFET_on        sbi     PORTC,3
                 #define CpFET_off       cbi     PORTC,3
                 #define CnFET_on        sbi     PORTB,0
                 #define CnFET_off       cbi     PORTB,0
                 
                 
                 ;*************************
                 ; Comparator definitions *
                 ;*************************
                 
                 .macro AcInit
                   ACMultiplexed
                 .endmacro
                 
                 
                 .macro AcPhaseA
                   ACChannel mux_a
                 .endmacro
                 
                 
                 .macro AcPhaseB
                   ACChannel mux_b
                 .endmacro
                 
                 
                 .macro AcPhaseC
                   ACChannel mux_c
                 .endmacro
                 
                 
                 ;*************************
                 ; Parameters             *
                 ;*************************
                 #undef     MOT_BRAKE      
                 #undef     READ_CALIBRATION
                 #define    F_CPU               16000000          ; 16Mhz oscilator 
                 #define    ZCF_CONST           7
                 
                 ;*************************
                 ; Power settings         *
                 ;*************************
                 #define    PCT_PWR_MIN         3                 ; Min power 3%
                 
                 ;*************************
                 ; Power curve            *
                 ;*************************
                 PWR_CURVE_POINT(01, 3500, 25)
                 PWR_CURVE_POINT(02, 7000, 50)
                 
                 ;*************************
                 ; Startup settings       *
                 ;*************************
                 #define    RPM_STEP_INITIAL    155
                 #define    RPM_STEP_MAX        200
                 #define    PCT_PWR_STARTUP     15
                 #define    PCT_PWR_MAX_STARTUP 20
                 #define    RPM_START_MIN_RPM   4200
                 #define    ENOUGH_GOODIES      20
                 
                 ;*************************
                 ; Run settings           *
                 ;*************************
                 #define    RPM_RUN_MIN_RPM     3200
                 
                 ;
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 ;
                 ;1. Da ich alles kostenlos zur Verfügung stelle, gebe ich keinerlei Garantie
                 ;   und übernehme auch keinerlei Haftung für die Folgen der Benutzung.
                 ;
                 ;2. Die Software ist ausschließlich zur privaten Nutzung bestimmt. Ich
                 ;   habe nicht geprüft, ob bei gewerblicher Nutzung irgendwelche Patentrechte
                 ;   verletzt werden oder sonstige rechtliche Einschränkungen vorliegen.
                 ;
                 ;3. Jeder darf Änderungen vornehmen, z.B. um die Funktion seinen Bedürfnissen
                 ;   anzupassen oder zu erweitern. Ich würde mich freuen, wenn ich weiterhin als
                 ;   Co-Autor in den Unterlagen erscheine und mir ein Link zur entprechenden Seite
                 ;   (falls vorhanden) mitgeteilt wird.
                 ;
                 ;4. Auch nach den Änderungen sollen die Software weiterhin frei sein, d.h. kostenlos bleiben.
                 ;
                 ;!! Wer mit den Nutzungbedingungen nicht einverstanden ist, darf die Software nicht nutzen !!
                 
                 #if defined(_include_ppm_inc_)
                   .include "ppm_light.inc"
                 
                   #define    micp_dis     0x00       ; disable ext0int
                   #define    micp_en      (1<<INT0)  ; enable ext0int
                   #define    micp_r_edge  (1<<ISC01)+(1<<ISC00)
                   #define    micp_f_edge  (1<<ISC01)
                   #define    micp_m_test  ISC00
                   #define    __ext_int0   rjmp ext_int0_isr
                   .macro __ext_int0_isr
                     __ext_micp_isr
                   .endmacro
                 #endif
                 
                 #if (rcp_in == 3)
                 #endif
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; external interrupt = rc pulse input
                 .macro __ext_micp_isr
                                 in      i_temp1, TCNT1L
                                 in      i_temp2, TCNT1H
                                 in      i_sreg, SREG
                                 sbis    PIND, rcp_in
                                 rjmp    falling_edge
                                 
                                 ldi     i_temp3, micp_f_edge
                                 out     MCUCR, i_temp3                            ; set next int to falling edge
                                 sts     start_rcpuls_l, i_temp1
                                 sts     start_rcpuls_h, i_temp2
                                 out     SREG, i_sreg
                                 reti
                 micp_fail:      
                                 out     SREG, i_sreg
                                 reti
                 falling_edge:
                                 ldi     i_temp3, micp_r_edge
                                 out     MCUCR, i_temp3                            ; set next int to rising edge
                                 lds     i_temp3, start_rcpuls_l  
                                 sub     i_temp1, i_temp3
                                 lds     i_temp3, start_rcpuls_h
                                 sbc     i_temp2, i_temp3
                 
                                 cpi     i_temp1, low (MAX_INT_RF*CLK_SCALE)
                                 ldi     i_temp3, high(MAX_INT_RF*CLK_SCALE)       ; test range high
                                 cpc     i_temp2, i_temp3
                                 brsh    micp_fail                                 ; through away
                                 cpi     i_temp1, low (MIN_INT_RF*CLK_SCALE)
                                 ldi     i_temp3, high(MIN_INT_RF*CLK_SCALE)       ; test range low
                                 cpc     i_temp2, i_temp3
                                 brlo    micp_fail                                 ; through away
                                 sbr     flags1, (1<<RC_PULS_UPDATED)              ; set to rc impuls value is ok !
                                 movw    new_rcpuls_l:new_rcpuls_h, i_temp1:i_temp2; save impuls length
                                 ldi     i_temp1, CONTROL_TOT*CLK_SCALE
                                 mov     control_timeout, i_temp1
                                 out     SREG, i_sreg
                                 reti
                 .endm
                 
                 .macro enable_input
                                 ldi     temp4, micp_en
                                 out     GIMSK, temp4                              
                 .endm 
                 
                 .macro disable_input
                                 ldi     temp4, micp_dis
                                 out     GIMSK, temp4
                 .endm 
                 
                 .macro init_input
                                 ldi     temp1, micp_r_edge
                                 out     MCUCR, temp1                              
                                 enable_input
                 .endm
                 #endif 
                 
                 
                 .equ    NO_POWER         = 256 - PWR_PCT_TO_VAL(PCT_PWR_MIN)    ; (POWER_OFF)
                 .equ    MAX_POWER        = 256 - POWER_RANGE                    ; (FULL_POWER)
                 .equ    CONTROL_TOT      = 31                                   ; time = NUMBER x 64ms
                 .equ    CLK_SCALE        = F_CPU / 8000000
                 
                 ;**** **** **** **** ****
                 ; Register Definitions
                 .def    i_sreg           = r1   ; status register save in interrupts
                 ;.def   ...              = r2   ; 
                 .def    temp5            = r3   ; 
                 .def    temp6            = r4   ; 
                 ;.def   ..               = r5   ;
                 .def    tcnt0_power_on   = r6   ; timer0 counts nFETs are switched on  
                 .def    tcnt0_pwroff     = r7   ; timer0 counts nFETs are switched off
                 .def    new_rcpuls_l     = r8
                 .def    new_rcpuls_h     = r9
                 
                 .def    TCNT1L_shadow    = r10
                 .def    TCNT1H_shadow    = r11
                 .def    control_timeout  = r12  ; 
                 
                 .def    sys_control      = r13
                 .def    t1_timeout       = r14
                 ;.def   ...              = r15
                 
                 
                 .def    temp1            = r16  ; main temporary
                 .def    temp2            = r17  ; main temporary
                 .def    temp3            = r18  ; main temporary
                 .def    temp4            = r19  ; main temporary
                 
                 .def    i_temp1          = r20  ; interrupt temporary
                 .def    i_temp2          = r21  ; interrupt temporary
                 .def    i_temp3          = r22  ; interrupt temporary
                 
                 .def    flags0  = r23   ; state flags
                         .equ    OCT1_PENDING    = 0     ; if set, output compare interrunpt is pending
                         .equ    OCT1_MSB        = 1     ; MSB of 17 bit timer
                         .equ    I_pFET_HIGH     = 2     ; set if over-current detect
                         .equ    B_FET           = 3     ; if set, A-FET state is to be changed
                         .equ    C_FET           = 4     ; if set, C-FET state is to be changed
                         .equ    A_FET           = 5     ; if set, A-FET state is to be changed
                 ;        .equ    ...            = 6     ; 
                         .equ    T1OVFL_FLAG     = 7     ; each timer1 overflow sets this flag - used for voltage + current watch
                 
                 .def    flags1  = r24   ; state flags
                         .equ    POWER_OFF       = 0     ; switch fets on disabled
                         .equ    FULL_POWER      = 1     ; 100% on - don't switch off, but do OFF_CYCLE working
                         .equ    NO_COMM         = 2     ; !(FULL_POWER or !PWM_OFF_CYCLE)
                         .equ    RC_PULS_UPDATED = 3     ; new rc-puls value available
                         .equ    PWM_OFF_CYCLE   = 4     ; if set, current off cycle is active
                 ;        .equ                   = 5     ; 
                 ;        .equ                   = 6     ; 
                 ;        .equ                   = 7     ; 
                 
                 .def    flags2  = r25
                         .equ    RPM_RANGE1      = 0     ; 
                         .equ    RPM_RANGE2      = 1     ; 
                         .equ    SCAN_TIMEOUT    = 2     ; if set a startup timeout occurred
                 ;       .equ    ...             = 3     ; 
                         .equ    RUN_MIN_RPM     = 4     ; 
                         .equ    STARTUP         = 5     ; if set startup-phase is active
                         .equ    RC_INTERVAL_OK  = 6     ; 
                         .equ    NO_SYNC         = 7     ; 
                 
                 ; here the XYZ registers are placed ( r26-r31)
                 
                 ; ZH = new_duty         ; PWM destination
                 
                 
                 ;**** **** **** **** ****
                 ; RAM Definitions
                 .dseg                                   
                 .org SRAM_START
                 
000060           last_tcnt1_l:         .byte   1         ; last timer1 value
000061           last_tcnt1_h:         .byte   1
000062           timing_l:             .byte   1         ; holds time of 4 commutations 
000063           timing_h:             .byte   1
000064           timing_x:             .byte   1
                 
000065           zc_blanking_time_l:   .byte   1         ; time from switch to comparator scan
000066           zc_blanking_time_h:   .byte   1       
000067           com_timing_l:         .byte   1         ; time from zero-crossing to switch of the appropriate FET
000068           com_timing_h:         .byte   1
000069           zc_wait_time_l:       .byte   1
00006a           zc_wait_time_h:       .byte   1
                 
00006b           strt_zc_wait_time_x:  .byte   1 
00006c           strt_zc_wait_time_h:  .byte   1
00006d           goodies:              .byte   1
                 
00006e           start_rcpuls_l:       .byte   1
00006f           start_rcpuls_h:       .byte   1
000070           stop_rcpuls_l:        .byte   1
000071           stop_rcpuls_h:        .byte   1
                 
000072           uart_data:            .byte   100       ; only for debug requirements
                 
                 
                 ;**** **** **** **** ****
                 ; ATmega8 interrupts
                 
                 ;.equ   INT0addr=$001   ; External Interrupt0 Vector Address
                 ;.equ   INT1addr=$002   ; External Interrupt1 Vector Address
                 ;.equ   OC2addr =$003   ; Output Compare2 Interrupt Vector Address
                 ;.equ   OVF2addr=$004   ; Overflow2 Interrupt Vector Address
                 ;.equ   ICP1addr=$005   ; Input Capture1 Interrupt Vector Address
                 ;.equ   OC1Aaddr=$006   ; Output Compare1A Interrupt Vector Address
                 ;.equ   OC1Baddr=$007   ; Output Compare1B Interrupt Vector Address
                 ;.equ   OVF1addr=$008   ; Overflow1 Interrupt Vector Address
                 ;.equ   OVF0addr=$009   ; Overflow0 Interrupt Vector Address
                 ;.equ   SPIaddr =$00a   ; SPI Interrupt Vector Address
                 ;.equ   URXCaddr=$00b   ; USART Receive Complete Interrupt Vector Address
                 ;.equ   UDREaddr=$00c   ; USART Data Register Empty Interrupt Vector Address
                 ;.equ   UTXCaddr=$00d   ; USART Transmit Complete Interrupt Vector Address
                 ;.equ   ADCCaddr=$00e   ; ADC Interrupt Vector Address
                 ;.equ   ERDYaddr=$00f   ; EEPROM Interrupt Vector Address
                 ;.equ   ACIaddr =$010   ; Analog Comparator Interrupt Vector Address
                 ;.equ   TWIaddr =$011   ; Irq. vector address for Two-Wire Interface
                 ;.equ   SPMaddr =$012   ; SPM complete Interrupt Vector Address
                 ;.equ   SPMRaddr =$012  ; SPM complete Interrupt Vector Address
                 ;-----bko-----------------------------------------------------------------
                 ; helper macroses
                 #if !defined(__ext_int0)
                 #endif
                 
                 #if !defined(__ext_int1)
                  #define __ext_int1 reti 
                  .macro __ext_int1_isr
                  .endmacro
                 #endif
                 ;**** **** **** **** ****
                 .cseg
                 .org 0
                 ;-----bko-----------------------------------------------------------------
                 ; reset and interrupt jump table
                 
000000 c01d                      rjmp    reset
000001 c065                      __ext_int0          ; ext_int0
000002 9518                      __ext_int1          ; ext_int1
000003 9518                      reti                ; t2oc_int
000004 9518                      reti                ; t2ovfl_int
000005 9518                      reti                ; icp1
000006 c085                      rjmp    t1oca_int
000007 9518                      reti                ; t1ocb_int
000008 c08e                      rjmp    t1ovfl_int
000009 c099                      rjmp    t0ovfl_int
00000a 9518                      reti                ; spi_int
00000b 9518                      reti                ; urxc
00000c 9518                      reti                ; udre
00000d 9518                      reti                ; utxc
00000e 9518                      reti                ; adc_int
00000f 9518                      reti                ; eep_int
000010 9518                      reti                ; aci_int
000011 9518                      reti                ; wire2_int
000012 9518                      reti                ; spmc_int
                 
                 
000013 0a0d      version:        .db     0x0d, 0x0a
000014 6b62
000015 794d
000016 7473
000017 7265
000018 2079
000019 3032
00001a 3134
00001b 7230
00001c 3630                      .db     "bk",Typ,"410r06"
00001d 0a0d                      .db     0x0d, 0x0a
                 
                 ;******************************************************************************
                 ;* MACRO
                 ;*      SetPWMi
                 ;* DECRIPTION
                 ;*      Set PWM immidiate
                 ;* USAGE
                 ;*      SetPWMi(val)
                 ;* STATISTICS
                 ;*      Register usage: none
                 ;******************************************************************************
                 .macro SetPWMi
                                 push    temp1
                                 push    temp2
                                 ldi     temp1, @0
                                 com     temp1
                                 rcall   set_pwm
                                 pop     temp2
                                 pop     temp1
                 .endmacro
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; init after reset
                 
00001e e004      reset:          ldi     temp1, high(RAMEND)     ; stack = RAMEND
00001f bf0e                      out     SPH, temp1
000020 e50f                      ldi     temp1, low(RAMEND)
000021 bf0d                      out     SPL, temp1
                 
                 #ifdef READ_CALIBRATION
                 #endif
                 #ifdef OVERCLOCK
                 #endif
                 
                         ; portB
000022 e000                      ldi     temp1, INIT_PB
000023 bb08                      out     PORTB, temp1
000024 e201                      ldi     temp1, DIR_PB
000025 bb07                      out     DDRB, temp1
                 
                         ; portC
000026 e002                      ldi     temp1, INIT_PC
000027 bb05                      out     PORTC, temp1
000028 e30a                      ldi     temp1, DIR_PC
000029 bb04                      out     DDRC, temp1
                 
                         ; portD
00002a e000                      ldi     temp1, INIT_PD
00002b bb02                      out     PORTD, temp1
00002c e300                      ldi     temp1, DIR_PD
00002d bb01                      out     DDRD, temp1
                 
                         ; timer0: PWM + beep control = 0x02     ; start timer0 with CK/8 (0.5³s/count)
00002e e002                      ldi     temp1, 0x02
00002f bf03                      out     TCCR0, temp1
                 
                         ; timer1: commutation control = 0x02    ; start timer1 with CK/8 (0.5³s/count)
000030 e002                      ldi     temp1, T1CK8
000031 bd0e                      out     TCCR1B, temp1
                 
                         ; reset state flags
000032 2777                      clr     flags0
000033 2788                      clr     flags1
000034 2799                      clr     flags2
                 
                         ; clear RAM
000035 27bb                      clr     XH
000036 e6a0                      ldi     XL, low (SRAM_START)
000037 2700                      clr     temp1
000038 930d      clear_ram:      st      X+, temp1
000039 37a3                      cpi     XL, uart_data+1
00003a f3e8                      brlo    clear_ram
                 
                         ; power off
00003b d222                      rcall   switch_power_off
                 
                         ; reset rc puls timeout
00003c e30e                      ldi     temp1, CONTROL_TOT*CLK_SCALE
00003d 2ec0                      mov     control_timeout, temp1
                                 
00003e d0b7                      rcall   wait260ms       ; wait a while
00003f d0b6                      rcall   wait260ms
                 
000040 d089                      rcall   beep_f1
000041 d0a8                      rcall   wait30ms
000042 d08a                      rcall   beep_f2
000043 d0a6                      rcall   wait30ms
000044 d08b                      rcall   beep_f3
000045 d0a4                      rcall   wait30ms
                 
                 control_start:  ; init variables
000046 930f
000047 931f
000048 e005
000049 9500
00004a d0d0
00004b 911f
00004c 910f                      SetPWMi(PWR_PCT_TO_VAL(PCT_PWR_MIN)-1)
00004d 24dd                      clr     sys_control
                 
                         ; init registers and interrupts
00004e e105                      ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
00004f bf08                      out     TIFR, temp1             ; clear TOIE1,OCIE1A & TOIE0
000050 bf09                      out     TIMSK, temp1            ; enable TOIE1,OCIE1A & TOIE0 interrupts
                 
000051 9478                      sei                             ; enable all interrupts
                 
000052 e003
000053 bf05
000054 e430
000055 bf3b                      init_input
000056 e02a      i_rc_puls1:     ldi     temp3, 10               ; wait for this count of receiving power off
000057 ff83      i_rc_puls2:     sbrs    flags1, RC_PULS_UPDATED
000058 cffe                      rjmp    i_rc_puls2
000059 0184                      movw    temp1:temp2, new_rcpuls_l:new_rcpuls_h
00005a 7f87                      cbr     flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
00005b 5908                      subi    temp1, low  (MIN_RC_PULS*CLK_SCALE)     ; power off received ?
00005c 4018                      sbci    temp2, high (MIN_RC_PULS*CLK_SCALE)
00005d f7c0                      brcc    i_rc_puls1              ; no - reset counter
00005e 952a                      dec     temp3                   ; yes - decrement counter
00005f f7b9                      brne    i_rc_puls2              ; repeat until zero
000060 94f8                      cli                             ; disable all interrupts
000061 d071                      rcall   beep_f4                 ; signal: rcpuls ready
000062 d070                      rcall   beep_f4
000063 d06f                      rcall   beep_f4
000064 9478                      sei                             ; enable all interrupts
                 
000065 d10c                      rcall   set_all_timings
                 
000066 c24b                      rjmp    init_startup
                 ;-----bko-----------------------------------------------------------------
000067 b54c
000068 b55d
000069 b61f
00006a 9b82
00006b c00a
00006c e062
00006d bf65
00006e 9340 006e
000070 9350 006f
000072 be1f
000073 9518
000074 be1f
000075 9518
000076 e063
000077 bf65
000078 9160 006e
00007a 1b46
00007b 9160 006f
00007d 0b56
00007e 3340
00007f e161
000080 0756
000081 f790
000082 3440
000083 e066
000084 0756
000085 f370
000086 6088
000087 014a
000088 e34e
000089 2ec4
00008a be1f
00008b 9518      ext_int0_isr:   __ext_int0_isr
                 ext_int1_isr:   __ext_int1_isr
                 ;-----bko-----------------------------------------------------------------
                 ; output compare timer1 interrupt
00008c b61f      t1oca_int:      in      i_sreg, SREG
00008d fd71                      sbrc    flags0, OCT1_MSB 
00008e c005                      rjmp    t1oca_intmsb
00008f 7f7e                      cbr     flags0, (1<<OCT1_PENDING) ; signal OCT1 passed
000090 b4ac                      in      TCNT1L_shadow, TCNT1L
000091 b4bd                      in      TCNT1H_shadow, TCNT1H
000092 be1f                      out     SREG, i_sreg
000093 9518                      reti
                 t1oca_intmsb:                
000094 7f7d                      cbr     flags0, (1<<OCT1_MSB) 
000095 be1f                      out     SREG, i_sreg
000096 9518                      reti                
                 ;-----bko-----------------------------------------------------------------
                 ; overflow timer1 / happens all 32768³s / 65536³s
000097 b61f      t1ovfl_int:     in      i_sreg, SREG
000098 6870                      sbr     flags0, (1<<T1OVFL_FLAG)
                 
000099 20ee                      tst     t1_timeout
00009a f009                      breq    t1ovfl_10
00009b 94ea                      dec     t1_timeout
                 
00009c 20cc      t1ovfl_10:      tst     control_timeout
00009d f411                      brne    t1ovfl_20
00009e 27ff                      clr     ZH
00009f c001                      rjmp    t1ovfl_99
0000a0 94ca      t1ovfl_20:      dec     control_timeout
                 
0000a1 be1f      t1ovfl_99:      out     SREG, i_sreg
0000a2 9518                      reti
                 ;-----bko-----------------------------------------------------------------
                 ; timer0 overflow interrupt
                 #ifdef HIGH_SIDE_PWM
                 #else
                 .macro PWMOff
                                 CnFET_off
                                 AnFET_off
                                 BnFET_off
                 .endm
                 .macro PWMOn
                                 ; switch appropriate nFET on
                                 sbrc    flags0, C_FET           ; is Cn choppered ?
                                 CnFET_on                        ; Cn on
                                 sbrc    flags0, A_FET           ; is An choppered ?
                                 AnFET_on                        ; An on
                                 sbrc    flags0, B_FET           ; is Bn choppered ?
                                 BnFET_on                        ; Bn on
                 .endm
                 .macro PWMCompOn
                                 sbrc    flags1, POWER_OFF
                                 rjmp    exit
                                 nop
                                 nop
                                 nop
                                 nop
                                 ; switch appropriate pFET on
                                 sbrc    flags0, C_FET           ; is Cp choppered ?
                                 CpFET_on                        ; Cp on
                                 sbrc    flags0, A_FET           ; is Ap choppered ?
                                 ApFET_on                        ; Ap on
                                 sbrc    flags0, B_FET           ; is Bp choppered ?
                                 BpFET_on                        ; Bp on
                 exit:                                    
                 .endm
                 
                 .macro PWMCompOff
                                 ; switch appropriate pFET off
                                 sbrc    flags0, C_FET           ; is Cp choppered ?
                                 CpFET_off                       ; Cp off
                                 sbrc    flags0, A_FET           ; is Ap choppered ?
                                 ApFET_off                       ; Ap off
                                 sbrc    flags0, B_FET           ; is Bp choppered ?
                                 BpFET_off                       ; Bp off
                 .endm
                 #endif
                 
                 
                 t0ovfl_int:     
0000a3 b61f                      in      i_sreg, SREG
0000a4 fd84                      sbrc    flags1, PWM_OFF_CYCLE
0000a5 c015                      rjmp    t0_on_cycle
                 t0_off_cycle:   
0000a6 2d47                      mov     i_temp1, tcnt0_pwroff
0000a7 3f4f                      cpi     i_temp1, 0xFF
0000a8 f039                      breq    t0_on_cycle_t1
                                 ;
0000a9 be72                      out     TCNT0, tcnt0_pwroff     ; reload t0
                                 ; We can just turn them all off as we only have one nFET on at a
                                 ; time, and interrupts are disabled during beeps.
0000aa 98c0
0000ab 9895
0000ac 98ac                      PWMOff
                                 #ifdef COMP_PWM
                                 #endif
                                 ; PWM state = off cycle
0000ad 6184                      sbr     flags1, (1<<PWM_OFF_CYCLE) + (1<<NO_COMM)
0000ae be1f                      out     SREG, i_sreg
0000af 9518                      reti
                 t0_on_cycle_t1:
                                 ; Off-load last cycle 
0000b0 98c0
0000b1 9895
0000b2 98ac                      PWMOff
0000b3 0000                      nop
0000b4 0000                      nop
0000b5 0000                      nop
0000b6 0000                      nop
0000b7 0000                      nop
0000b8 0000                      nop
0000b9 0000                      nop
0000ba 0000                      nop
                 t0_on_cycle:
0000bb be62                      out     TCNT0, tcnt0_power_on   ; reload t0
                                 #ifdef COMP_PWM
                                 #endif
0000bc fd80                      sbrc    flags1, POWER_OFF
0000bd c006                      rjmp    t0_on_cycle_tcnt
0000be fd74
0000bf 9ac0
0000c0 fd75
0000c1 9a95
0000c2 fd73
0000c3 9aac                      PWMOn
                 t0_on_cycle_tcnt:
0000c4 7e89                      cbr     flags1, (1<<FULL_POWER) + (1<<NO_COMM) + (1<<PWM_OFF_CYCLE); PWM state = on cycle
0000c5 2077                      tst     tcnt0_pwroff
0000c6 f409                      brne    t0_on_cycle_not_full_power
0000c7 6182                      sbr     flags1, (1<<FULL_POWER) + (1<<PWM_OFF_CYCLE)
                 t0_on_cycle_not_full_power:
0000c8 be1f                      out     SREG, i_sreg
0000c9 9518                      reti                   
                 ;-----bko-----------------------------------------------------------------
                 ; beeper: timer0 is set to 1³s/count
0000ca ec38      beep_f1:        ldi     temp4, 200
0000cb e510                      ldi     temp2, 80
0000cc c009                      rjmp    beep
                 
0000cd eb34      beep_f2:        ldi     temp4, 180
0000ce e614                      ldi     temp2, 100
0000cf c006                      rjmp    beep
                 
0000d0 ea30      beep_f3:        ldi     temp4, 160
0000d1 e718                      ldi     temp2, 120
0000d2 c003                      rjmp    beep
                 
0000d3 e634      beep_f4:        ldi     temp4, 100
0000d4 ec18                      ldi     temp2, 200
0000d5 c000                      rjmp    beep
                 
0000d6 2700      beep:           clr     temp1
0000d7 bf02                      out     TCNT0, temp1
0000d8 9aad                      BpFET_on                                ; BpFET on
0000d9 9a95                      AnFET_on                                ; CnFET on
0000da b702      beep_BpCn10:    in      temp1, TCNT0
0000db 3200                      cpi     temp1, 16*CLK_SCALE             ; 16us on
0000dc f7e9                      brne    beep_BpCn10
0000dd 98ad                      BpFET_off                               ; BpFET off
0000de 9895                      AnFET_off                               ; CnFET off
0000df e120                      ldi     temp3, 8*CLK_SCALE              ; 2040us off
0000e0 2700      beep_BpCn12:    clr     temp1
0000e1 bf02                      out     TCNT0, temp1
0000e2 b702      beep_BpCn13:    in      temp1, TCNT0
0000e3 1703                      cp      temp1, temp4
0000e4 f7e9                      brne    beep_BpCn13
0000e5 952a                      dec     temp3
0000e6 f7c9                      brne    beep_BpCn12
0000e7 951a                      dec     temp2
0000e8 f769                      brne    beep
0000e9 9508                      ret
                 
0000ea e01f      wait30ms:       ldi     temp2, 15
0000eb e120      beep_BpCn20:    ldi     temp3, 8*CLK_SCALE
0000ec 2700      beep_BpCn21:    clr     temp1
0000ed bf02                      out     TCNT0, temp1
0000ee b702      beep_BpCn22:    in      temp1, TCNT0
0000ef 3f0f                      cpi     temp1, 255
0000f0 f7e9                      brne    beep_BpCn22
0000f1 952a                      dec     temp3
0000f2 f7c9                      brne    beep_BpCn21
0000f3 951a                      dec     temp2
0000f4 f7b1                      brne    beep_BpCn20
0000f5 9508                      ret
                 
                         ; 256 periods = 261ms silence
0000f6 e810      wait260ms:      ldi     temp2, 128
0000f7 e120      beep2_BpCn20:   ldi     temp3, 8*CLK_SCALE
0000f8 2700      beep2_BpCn21:   clr     temp1
0000f9 bf02                      out     TCNT0, temp1
0000fa b702      beep2_BpCn22:   in      temp1, TCNT0
0000fb 3f0f                      cpi     temp1, 255
0000fc f7e9                      brne    beep2_BpCn22
0000fd 952a                      dec     temp3
0000fe f7c9                      brne    beep2_BpCn21
0000ff 951a                      dec     temp2
000100 f7b1                      brne    beep2_BpCn20
000101 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 evaluate_rc_puls:
000102 ff83
000103 9508
000104 0184
000105 7f87
000106 5908
000107 4018
000108 f410
000109 2700
00010a 2711
00010b 9516
00010c 9507
00010d 9516
00010e 9507
00010f 9516
000110 9507
000111 3c07
000112 f008
000113 ec07
000114 2ff0
000115 9508                      EvaluatePWC
                 ;-----bko-----------------------------------------------------------------
                 evaluate_sys_state:
000116 2d0d                      mov     temp1, sys_control      ; Build up sys_control to POWER_RANGE
000117 3c07                      cpi     temp1, POWER_RANGE - 1
000118 f009                      breq    evaluate_sys_state_exit
000119 94d3                      inc     sys_control             ; 
                 evaluate_sys_state_exit:                
00011a 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_pwm
                 ;* DECRIPTION
                 ;*      Calculates tcnt0 values for ON and off cycles.
                 ;*      Performs PWM correction.
                 ;* USAGE
                 ;*      temp1
                 ;* STATISTICS
                 ;*      Register usage: temp1, temp2
                 ;******************************************************************************
                 set_pwm:
00011b 2f10                      mov     temp2, temp1
00011c 5317                      subi    temp2, -(POWER_RANGE + 1)
00011d 9510                      com     temp2  
00011e 5f1e                      subi    temp2, -2               ; Make it shorter by 2 cycles
00011f 3f0e                      cpi     temp1, 0xFE
000120 f008                      brcs    set_pwm_01
000121 ef0d                      ldi     temp1, 0xFF  - 2        ; Limit to 0xFF
                 set_pwm_01:
000122 5f0e                      subi    temp1, -2               ; Make it shorter by 2 cycles 
000123 0138                      movw    tcnt0_power_on:tcnt0_pwroff, temp1:temp2
000124 9508                      ret
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      eval_power_state
                 ;* DECRIPTION
                 ;*      Evaluates current state
                 ;* USAGE
                 ;*      temp1
                 ;* STATISTICS
                 ;*      Register usage: none
                 ;******************************************************************************
                 eval_power_state:
000125 3309                      cpi     temp1, MAX_POWER+1
000126 f410                      brsh    not_full_power
000127 7f8e                      cbr     flags1, (1<<POWER_OFF)
000128 c005                      rjmp    eval_power_state_exit
000129 3f0a      not_full_power: cpi     temp1, NO_POWER
00012a f010                      brlo    neither_full_nor_off
00012b 6081                      sbr     flags1, (1<<POWER_OFF)
00012c c001                      rjmp    eval_power_state_exit
                 neither_full_nor_off:
00012d 7f8e                      cbr     flags1, (1<<POWER_OFF)
                 eval_power_state_exit:    
00012e 9508                      ret
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_new_duty
                 ;* DECRIPTION
                 ;*     1) Evaluates duty cycle
                 ;*     2) Limits power to sys_control
                 ;*     3) Limits RPM ranges power
                 ;* USAGE
                 ;*      ZH (0 - POWER_RANGE - 1)
                 ;* STATISTICS
                 ;*      Register usage: temp1, temp2, temp3 
                 ;******************************************************************************
                 .macro CheckRPMi
                                 cpi     temp3, LOW(RPM_TO_COMM_TIME(@0)*4*CLK_SCALE)             
                                 ldi     temp1, HIGH(RPM_TO_COMM_TIME(@0)*4*CLK_SCALE)
                                 cpc     temp4, temp1
                                 ldi     temp1, BYTE3(RPM_TO_COMM_TIME(@0)*4*CLK_SCALE)
                                 cpc     temp5, temp1
                 .endmacro
                 
                 set_new_duty:   
00012f 2e4f                      mov     temp6, ZH
000130 144d                      cp      temp6, sys_control      ; Limit PWM to sys_control
000131 f008                      brcs    set_new_duty_no_limit
000132 2c4d                      mov     temp6, sys_control
                 set_new_duty_no_limit:
000133 6193                      sbr     flags2, (1<<RPM_RANGE1) + (1<<RPM_RANGE2) + (1<<RUN_MIN_RPM)
000134 9130 0063                 lds     temp4, timing_h
000136 9030 0064                 lds     temp5, timing_x
000138 303d                      cpi     temp4, 0x0d*CLK_SCALE/2 ;  ~ 20.000 RPM
000139 e000                      ldi     temp1, 0x0
00013a 0630                      cpc     temp5, temp1
00013b f428                      brcc    set_new_duty_low_ranges
                                 ; High RPM finish ASAP
                 set_new_duty_set_pwm:                
00013c 2d04                      mov     temp1, temp6
00013d 9500                      com     temp1
00013e dfe6                      rcall   eval_power_state        ; evaluate power state
00013f dfdb                      rcall   set_pwm                 ; set new PWM
000140 9508                      ret                
                 set_new_duty_low_ranges:
                                 ; With low RPM we have more time for calculations. 
                                 ; We assume that  RUN_MIN_RPM < RPM_RUN_RANGE_02 < RPM_RUN_RANGE_02
000141 9120 0062                 lds     temp3, timing_l
                                 ;  Check for range 02
000143 3a20
000144 e20c
000145 0730
000146 e000
000147 0630                      CheckRPMi(RPM_RUN_RANGE_02)
000148 f398                      brcs    set_new_duty_set_pwm
000149 7f9d                      cbr     flags2, (1<<RPM_RANGE2)
00014a e614                      ldi     temp2, PWR_PCT_TO_VAL(PCT_PWR_MAX_RPM_02)
00014b 1514                      cp      temp2, temp6
00014c f408                      brcc    set_new_duty_range_01
00014d 2e41                      mov     temp6, temp2  
                 set_new_duty_range_01:
                                 ;  Check for range 01               
00014e 3428
00014f e509
000150 0730
000151 e000
000152 0630                      CheckRPMi(RPM_RUN_RANGE_01)
000153 f340                      brcs    set_new_duty_set_pwm
000154 7f9e                      cbr     flags2, (1<<RPM_RANGE1)
000155 e312                      ldi     temp2, PWR_PCT_TO_VAL(PCT_PWR_MAX_RPM_01)
000156 1514                      cp      temp2, temp6
000157 f408                      brcc    set_new_duty_min_rpm
000158 2e41                      mov     temp6, temp2   
                 set_new_duty_min_rpm:                
                                 ;  Check for minimum RPM
000159 3a28
00015a e601
00015b 0730
00015c e000
00015d 0630                      CheckRPMi(RPM_RUN_MIN_RPM)
00015e f2e8                      brcs    set_new_duty_set_pwm
00015f 7e9f                      cbr     flags2, (1<<RUN_MIN_RPM)
000160 cfdb                      rjmp    set_new_duty_set_pwm
                                 
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_new_duty_strt
                 ;* DECRIPTION
                 ;*     1) Evaluates duty cycle
                 ;*     2) Limits power to sys_control
                 ;*     3) Constraints power in range: PWR_PCT_TO_VAL(PCT_PWR_STARTUP)..PWR_PCT_TO_VAL(PCT_PWR_MAX_STARTUP)
                 ;* USAGE
                 ;*      ZH (0 - POWER_RANGE-1)
                 ;* STATISTICS
                 ;*      Register usage: temp1, temp2, temp3 
                 ;******************************************************************************
                 set_new_duty_strt:   
000161 2e4f                      mov     temp6, ZH
000162 144d                      cp      temp6, sys_control      ; Limit PWM to sys_control
000163 f008                      brcs    set_new_duty_strt_01
000164 2c4d                      mov     temp6, sys_control
                 set_new_duty_strt_01:
000165 e218                      ldi     temp2, PWR_PCT_TO_VAL(PCT_PWR_MAX_STARTUP)
000166 1514                      cp      temp2, temp6
000167 f408                      brcc    set_new_duty_strt_02
000168 2e41                      mov     temp6, temp2   
                 set_new_duty_strt_02:
000169 e11e                      ldi     temp2, PWR_PCT_TO_VAL(PCT_PWR_STARTUP)
00016a 1641                      cp      temp6, temp2
00016b f408                      brcc    set_new_duty_strt_03
00016c 2e41                      mov     temp6, temp2
                 set_new_duty_strt_03:                
00016d 2d04                      mov     temp1, temp6
00016e 9500                      com     temp1
00016f dfb5                      rcall   eval_power_state        ; evaluate power state
000170 dfaa                      rcall   set_pwm                 ; set new PWM
000171 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 set_all_timings:
000172 efc8                      ldi     YL, high(RPM_TO_COMM_TIME(RPM_STEP_INITIAL)*CLK_SCALE)
000173 e0d1                      ldi     YH, byte3(RPM_TO_COMM_TIME(RPM_STEP_INITIAL)*CLK_SCALE)
000174 93c0 006c                 sts     strt_zc_wait_time_h, YL
000176 93d0 006b                 sts     strt_zc_wait_time_x, YH
000178 ef2f                      ldi     temp3, 0xff
000179 e13f                      ldi     temp4, 0x1f
00017a 9320 0065                 sts     zc_blanking_time_l, temp3
00017c 9330 0066                 sts     zc_blanking_time_h, temp4
00017e 9320 0067                 sts     com_timing_l, temp3
000180 9330 0068                 sts     com_timing_h, temp4
                 set_timing_v:   
000182 e0e2                      ldi     ZL, 0x02
000183 2e3e                      mov     temp5, ZL
000184 93e0 0064                 sts     timing_x, ZL
000186 ef3f                      ldi     temp4, 0xff
000187 9330 0063                 sts     timing_h, temp4
000189 ef2f                      ldi     temp3, 0xff
00018a 9320 0062                 sts     timing_l, temp3
00018c 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 update_timing:  
00018d 94f8                      cli
00018e b50c                      in      temp1, TCNT1L
00018f b51d                      in      temp2, TCNT1H
000190 9478                      sei
000191 2ea0                      mov     TCNT1L_shadow, temp1
000192 2eb1                      mov     TCNT1H_shadow, temp2
                                 ; calculate this commutation time
000193 9120 0060                 lds     temp3, last_tcnt1_l
000195 9130 0061                 lds     temp4, last_tcnt1_h
000197 9300 0060                 sts     last_tcnt1_l, temp1
000199 9310 0061                 sts     last_tcnt1_h, temp2
00019b 1b02                      sub     temp1, temp3
00019c 0b13                      sbc     temp2, temp4
                                 ; No sync correction
00019d ff97                      sbrs     flags2, NO_SYNC
00019e c004                      rjmp     update_t_normal
00019f 2433                      clr      temp5
0001a0 2f20                      mov      temp3, temp1
0001a1 2f31                      mov      temp4, temp2
0001a2 c01e                      rjmp     update_t90
                 update_t_normal:           
0001a3 2444                      clr     temp6     
                                 ; calculate next waiting times - timing(-l-h-x) holds the time of 4 commutations
0001a4 9120 0062                 lds     temp3, timing_l
0001a6 9130 0063                 lds     temp4, timing_h
0001a8 9030 0064                 lds     temp5, timing_x
                                 ; t*3/4 = t - t/4
0001aa 01e9                      movw    YL:YH, temp3:temp4      ; copy timing to Y:temp6
0001ab 9436                      lsr     temp5                   ; build a quarter
0001ac 95d7                      ror     YH
0001ad 95c7                      ror     YL
0001ae 9436                      lsr     temp5
0001af 95d7                      ror     YH                      ; temp5 no longer needed (should be 0)
0001b0 95c7                      ror     YL
0001b1 9030 0064                 lds     temp5, timing_x         ; reload original timing_x
0001b3 1b2c                      sub     temp3, YL               ; subtract quarter from timing
0001b4 0b3d                      sbc     temp4, YH
0001b5 0834                      sbc     temp5, temp6
0001b6 0f20                      add     temp3, temp1            ; .. and add the new time
0001b7 1f31                      adc     temp4, temp2
0001b8 1c34                      adc     temp5, temp6                
                                 ; limit RPM to 120.000
0001b9 342c                      cpi     temp3, 0x4c             ; 0x14c = 120.000 RPM
0001ba e001                      ldi     temp1, 0x1
0001bb 0730                      cpc     temp4, temp1
0001bc 0434                      cpc     temp5, temp6
0001bd f418                      brcc    update_t90
                                 ; limit by reducing power
0001be 20dd                      tst     sys_control
0001bf f009                      breq    update_t90
0001c0 94da                      dec     sys_control             
                 update_t90:     
0001c1 9320 0062                 sts     timing_l, temp3
0001c3 9330 0063                 sts     timing_h, temp4
0001c5 9230 0064                 sts     timing_x, temp5
0001c7 e013                      ldi     temp2, 3
0001c8 1631                      cp      temp5, temp2              ; limit range to 0x2ffff
0001c9 f008                      brcs    update_t99
0001ca dfb7                      rcall   set_timing_v
                 update_t99:
0001cb 9436                      lsr     temp5                   
0001cc 9537                      ror     temp4
0001cd 9527                      ror     temp3
0001ce 9436                      lsr     temp5
0001cf 9537                      ror     temp4
0001d0 9527                      ror     temp3
0001d1 0189                      movw    temp1:temp2, temp3:temp4
0001d2 9536                      lsr     temp4                     ; x always 0 at this stage (0x2ffff / 4 = 0xBFFF)
0001d3 9527                      ror     temp3
0001d4 9536                      lsr     temp4
0001d5 9527                      ror     temp3
0001d6 9320 0065                 sts     zc_blanking_time_l, temp3 ; save for zero crossing blanking time (15 deg) 
0001d8 9330 0066                 sts     zc_blanking_time_h, temp4
0001da 9320 0067                 sts     com_timing_l, temp3       ; save for timing advance delay (15 deg)
0001dc 9330 0068                 sts     com_timing_h, temp4
0001de 0f02                      add     temp1, temp3
0001df 1f13                      adc     temp2, temp4
0001e0 9300 0069                 sts     zc_wait_time_l, temp1     ; save for zero crossing timeout (60 + 15 = 75 deg)
0001e2 9310 006a                 sts     zc_wait_time_h, temp2    
0001e4 9508                      ret               
                 ;-----bko-----------------------------------------------------------------
                 correct_next_timing:          
0001e5 91c0 0069                 lds     YL, zc_wait_time_l
0001e7 91d0 006a                 lds     YH, zc_wait_time_h
0001e9 94f8                      cli
0001ea 0dca                      add     YL, TCNT1L_shadow
0001eb 1ddb                      adc     YH, TCNT1H_shadow
0001ec bddb                      out     OCR1AH, YH
0001ed bdca                      out     OCR1AL, YL
0001ee 9478                      sei
0001ef 6071                      sbr     flags0, (1<<OCT1_PENDING)
                 correct_timing_loop:      
0001f0 fd70                      sbrc    flags0, OCT1_PENDING
0001f1 cffe                      rjmp    correct_timing_loop
0001f2 91c0 0069                 lds     YL, zc_wait_time_l
0001f4 91d0 006a                 lds     YH, zc_wait_time_h
0001f6 0fcc                      lsl     YL
0001f7 1fdd                      rol     YH
0001f8 94f8                      cli
0001f9 0dca                      add     YL, TCNT1L_shadow
0001fa 1ddb                      adc     YH, TCNT1H_shadow
0001fb bddb                      out     OCR1AH, YH
0001fc bdca                      out     OCR1AL, YL
0001fd 9478                      sei
0001fe 6071                      sbr     flags0, (1<<OCT1_PENDING)
0001ff 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 calc_next_timing:
000200 91c0 0067                 lds     YL, com_timing_l
000202 91d0 0068                 lds     YH, com_timing_h
                                 ; ZC filter phase correction
000204 50cb                      subi    YL, (ZCF_CONST * 13 + 4) / 8
000205 40d0                      sbci    YH, 0
                                 ;
000206 df86                      rcall   update_timing
000207 91d0 0068                 lds     YH, com_timing_h
000209 91c0 0067                 lds     YL, com_timing_l
00020b 94f8                      cli
00020c 0dca                      add     YL, TCNT1L_shadow
00020d 1ddb                      adc     YH, TCNT1H_shadow
00020e bddb                      out     OCR1AH, YH
00020f bdca                      out     OCR1AL, YL
000210 9478                      sei
000211 6071                      sbr     flags0, (1<<OCT1_PENDING)
000212 9508                      ret
                                 
                 wait_for_commutation:
000213 fd70                      sbrc    flags0, OCT1_PENDING
000214 cffe                      rjmp    wait_for_commutation
                 
                 set_zc_blanking_time:
000215 91d0 0066                 lds     YH, zc_blanking_time_h
000217 91c0 0065                 lds     YL, zc_blanking_time_l
000219 94f8                      cli
00021a 0dca                      add     YL, TCNT1L_shadow
00021b 1ddb                      adc     YH, TCNT1H_shadow
00021c bddb                      out     OCR1AH, YH
00021d bdca                      out     OCR1AL, YL
00021e 9478                      sei
00021f 6071                      sbr     flags0, (1<<OCT1_PENDING)
000220 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 wait_for_zc_blank:
                         ; don't waste time while waiting - do some controls
000221 fd83                      sbrc    flags1, RC_PULS_UPDATED
000222 dedf                      rcall   evaluate_rc_puls
000223 df0b                      rcall   set_new_duty
                 wait_for_zc_blank_loop:      
000224 ff83                      sbrs    flags1, RC_PULS_UPDATED
000225 c002                      rjmp    wait_for_zc_blank_loop2
000226 dedb                      rcall   evaluate_rc_puls
000227 df07                      rcall   set_new_duty
                 wait_for_zc_blank_loop2:                
000228 fd70                      sbrc    flags0, OCT1_PENDING
000229 cffa                      rjmp    wait_for_zc_blank_loop
                         ; set ZC timeout
00022a 91d0 006a                 lds     YH, zc_wait_time_h
00022c 91c0 0069                 lds     YL, zc_wait_time_l
                                 ; ZC filter phase correction
00022e e00b                      ldi     temp1, (ZCF_CONST * 13 + 4) / 8
00022f 2444                      clr     temp6
000230 0fc0                      add     YL, temp1
000231 1dd4                      adc     YH, temp6
                                 ;
000232 94f8                      cli
000233 0dca                      add     YL, TCNT1L_shadow
000234 1ddb                      adc     YH, TCNT1H_shadow
000235 bddb                      out     OCR1AH, YH
000236 bdca                      out     OCR1AL, YL
000237 9478                      sei
000238 6071                      sbr     flags0, (1<<OCT1_PENDING)
000239 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 start_timeout:  
00023a 7f7d                      cbr     flags0, (1<<OCT1_MSB)
00023b e6c4                      ldi     YL, 50*CLK_SCALE
00023c e0d0                      ldi     YH, 0
00023d df4f                      rcall   update_timing
                 start_timeout_loop:                
00023e fd70                      sbrc    flags0, OCT1_PENDING
00023f cffe                      rjmp    start_timeout_loop      ; ZC blanking interval
000240 91c0 006c                 lds     YL, strt_zc_wait_time_h
000242 91d0 006b                 lds     YH, strt_zc_wait_time_x
000244 2444                      clr     temp6
000245 94f8                      cli
000246 2d0a                      mov     temp1, TCNT1L_shadow
000247 2d1b                      mov     temp2, TCNT1H_shadow
000248 0d04                      add     temp1, temp6
000249 1f1c                      adc     temp2, YL
00024a bd1b                      out     OCR1AH, temp2
00024b bd0a                      out     OCR1AL, temp1
00024c 6071                      sbr     flags0, (1<<OCT1_PENDING)
00024d 23dd                      tst     YH
00024e f009                      breq    start_timeout_no_msb
00024f 6072                      sbr     flags0, (1<<OCT1_MSB)                
                 start_timeout_no_msb:                
000250 9478                      sei
000251 50c4                      subi    YL, 4
000252 40d0                      sbci    YH, 0
000253 38c6                      cpi     YL, high(RPM_TO_COMM_TIME(RPM_STEP_MAX)*CLK_SCALE)
000254 e001                      ldi     temp1, byte3(RPM_TO_COMM_TIME(RPM_STEP_MAX)*CLK_SCALE)
000255 07d0                      cpc     YH, temp1
000256 f410                      brcc    start_timeout_no_lim
000257 efc8                      ldi     YL, high(RPM_TO_COMM_TIME(RPM_STEP_INITIAL)*CLK_SCALE)         
000258 e0d1                      ldi     YH, byte3(RPM_TO_COMM_TIME(RPM_STEP_INITIAL)*CLK_SCALE)         
                 start_timeout_no_lim:
000259 93c0 006c                 sts     strt_zc_wait_time_h, YL
00025b 93d0 006b                 sts     strt_zc_wait_time_x, YH
00025d 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 switch_power_off:
00025e e0f5                      ldi     ZH, PWR_PCT_TO_VAL(PCT_PWR_MIN)-1          ; ZH is new_duty
00025f 930f
000260 931f
000261 e005
000262 9500
000263 deb7
000264 911f
000265 910f                      SetPWMi(PWR_PCT_TO_VAL(PCT_PWR_MIN)-1)
                 
000266 e000                      ldi     temp1, 0                ; reset limiter
000267 2ed0                      mov     sys_control, temp1
                 
000268 e000                      ldi     temp1, INIT_PB          ; all off
000269 bb08                      out     PORTB, temp1
00026a e002                      ldi     temp1, INIT_PC          ; all off
00026b bb05                      out     PORTC, temp1
00026c e000                      ldi     temp1, INIT_PD          ; all off
00026d bb02                      out     PORTD, temp1
                 
00026e 6081                      sbr     flags1, (1<<POWER_OFF)  ; disable power on
00026f 6290                      sbr     flags2, (1<<STARTUP)
000270 9508                      ret                             ; motor is off
                 ;-----bko-----------------------------------------------------------------
                 motor_brake:
                 #ifdef MOT_BRAKE
                 #endif
000271 9508                      ret
                 
                 no_sync_poff:
000272 6081                      sbr     flags1, (1<<POWER_OFF)
000273 e000                      ldi     temp1, INIT_PB          ; all off
000274 bb08                      out     PORTB, temp1
000275 e002                      ldi     temp1, INIT_PC          ; all off
000276 bb05                      out     PORTC, temp1
000277 e000                      ldi     temp1, INIT_PD          ; all off
000278 bb02                      out     PORTD, temp1
000279 9ac5                      DbgLEDOn
00027a 9508                      ret
                 
                 
                 wait64ms:
00027b e002                      ldi     temp1, 1*CLK_SCALE
00027c 2ee0                      mov     t1_timeout, temp1
                 wait120ms_wait_for_t1:    
00027d 20ee                      tst     t1_timeout
00027e f7f1                      brne    wait120ms_wait_for_t1
00027f 9508                      ret
                 
                 pre_align:      
000280 e000                      ldi     temp1, INIT_PB  ; all off
000281 bb08                      out     PORTB, temp1
000282 e000                      ldi     temp1, INIT_PD  ; all off
000283 bb02                      out     PORTD, temp1
000284 e002                      ldi     temp1, INIT_PC  ; all off
000285 bb05                      out     PORTC, temp1
                 
000286 e208                      ldi     temp1, 20*CLK_SCALE
000287 950a      pp_FETs_off_wt: dec     temp1
000288 f7f1                      brne    pp_FETs_off_wt
                 #ifdef CHARGE_BOOTSTRAP
                 #endif                
000289 7f8e                      cbr     flags1, (1<<POWER_OFF)  ; enable power
00028a e10e                      ldi     temp1, PWR_PCT_TO_VAL(PCT_PWR_STARTUP)      ; set limiter
00028b 2ed0                      mov     sys_control, temp1
00028c 930f
00028d 931f
00028e e007
00028f 9500
000290 de8a
000291 911f
000292 910f                      SetPWMi(PWR_PCT_TO_VAL(PCT_PWR_STARTUP)*1/4);
000293 d174                      rcall   com6com1
000294 d142                      rcall   com1com2
000295 9aad                      BpFET_on
000296 dfe4                      rcall   wait64ms
000297 dfe3                      rcall   wait64ms
000298 930f
000299 931f
00029a e00f
00029b 9500
00029c de7e
00029d 911f
00029e 910f                      SetPWMi(PWR_PCT_TO_VAL(PCT_PWR_STARTUP)*2/4);
00029f dfdb                      rcall   wait64ms
0002a0 930f
0002a1 931f
0002a2 e106
0002a3 9500
0002a4 de76
0002a5 911f
0002a6 910f                      SetPWMi(PWR_PCT_TO_VAL(PCT_PWR_STARTUP)*3/4);
0002a7 dfd3                      rcall   wait64ms
0002a8 930f
0002a9 931f
0002aa e10e
0002ab 9500
0002ac de6e
0002ad 911f
0002ae 910f                      SetPWMi(PWR_PCT_TO_VAL(PCT_PWR_STARTUP));
0002af 98ad                      BpFET_off               
0002b0 d12d                      rcall   com2com3
0002b1 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 ; **** startup loop ****
0002b2 dfab      init_startup:   rcall   switch_power_off
0002b3 dfbd                      rcall   motor_brake
                 wait_for_power_on:
                                 ;DbgLEDOn
                 
0002b4 de4d                      rcall   evaluate_rc_puls
0002b5 30f7                      cpi     ZH, PWR_PCT_TO_VAL(PCT_PWR_MIN) + 1
0002b6 f3e8                      brcs    wait_for_power_on
0002b7 9837
0002b8 b700
0002b9 6008
0002ba bf00                      AcInit
0002bb dfc4                      rcall   pre_align
                                 ;DbgLEDOn
                 
0002bc 779f                      cbr     flags2, (1<<NO_SYNC) 
0002bd 7f9b                      cbr     flags2, (1<<SCAN_TIMEOUT)
0002be e000                      ldi     temp1, 0
0002bf 9300 006d                 sts     goodies, temp1
0002c1 e500                      ldi     temp1, 40*CLK_SCALE; x 32msec
0002c2 2ee0                      mov     t1_timeout, temp1
0002c3 deae                      rcall   set_all_timings
0002c4 df75                      rcall   start_timeout
0002c5 c00c                      rjmp    start3
                 ;-----bko-----------------------------------------------------------------
                 ; **** start control loop ****
                 
                 ; state 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 start1:         
0002c6 d0f8                      rcall   wait_for_low_strt
0002c7 d0e3                      rcall   wait_for_high_strt
                 ;                rcall   wait_for_test
0002c8 ff70                      sbrs    flags0, OCT1_PENDING
0002c9 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
0002ca d10c                      rcall   com1com2
0002cb df6e                      rcall   start_timeout
                 
                 ; state 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
0002cc d0de                      rcall   wait_for_high_strt
0002cd d0f1                      rcall   wait_for_low_strt
                 ;                rcall   wait_for_test
0002ce ff70                      sbrs    flags0, OCT1_PENDING
0002cf 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
0002d0 d10d                      rcall   com2com3
0002d1 df68                      rcall   start_timeout
                 
                 ; state 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 start3:
0002d2 d0ec                      rcall   wait_for_low_strt
0002d3 d0d7                      rcall   wait_for_high_strt
                 ;                rcall   wait_for_test
0002d4 ff70                      sbrs    flags0, OCT1_PENDING
0002d5 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
0002d6 d115                      rcall   com3com4
0002d7 df62                      rcall   start_timeout
                 
                 ; state 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
0002d8 d0d2                      rcall   wait_for_high_strt
0002d9 d0e5                      rcall   wait_for_low_strt
                 ;                rcall   wait_for_test
0002da ff70                      sbrs    flags0, OCT1_PENDING
0002db 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
0002dc d116                      rcall   com4com5
0002dd df5c                      rcall   start_timeout
                 
                 ; state 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
0002de d0e0                      rcall   wait_for_low_strt
0002df d0cb                      rcall   wait_for_high_strt
                 ;                rcall   wait_for_test
0002e0 ff70                      sbrs    flags0, OCT1_PENDING
0002e1 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
0002e2 d11e                      rcall   com5com6
0002e3 de32                      rcall   evaluate_sys_state
0002e4 de1d                      rcall   evaluate_rc_puls
0002e5 de7b                      rcall   set_new_duty_strt
0002e6 df53                      rcall   start_timeout
                 
                 ; state 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
0002e7 d0c3                      rcall   wait_for_high_strt
0002e8 d0d6                      rcall   wait_for_low_strt
                 ;                rcall   wait_for_test
0002e9 ff70                      sbrs    flags0, OCT1_PENDING
0002ea 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
0002eb d11c                      rcall   com6com1
                                 ; no throttle 
0002ec 30f6                      cpi     ZH, PWR_PCT_TO_VAL(PCT_PWR_MIN)
0002ed f220                      brcs    init_startup
                                 ; timeout 
0002ee 20ee                      tst     t1_timeout
0002ef f211                      breq    init_startup
                                 
0002f0 9100 006d                 lds     temp1, goodies
0002f2 fd92                      sbrc    flags2, SCAN_TIMEOUT
0002f3 2700                      clr     temp1
0002f4 9503                      inc     temp1
0002f5 9300 006d                 sts     goodies,  temp1
0002f7 7f9b                      cbr     flags2, (1<<SCAN_TIMEOUT)
0002f8 3104                      cpi     temp1, ENOUGH_GOODIES
0002f9 f040                      brcs    s6_start1
                                 ; We need some rotations without lost sync, to be able to trust timing..
0002fa 9100 0063                 lds     temp1, timing_h 
0002fc 340a                      cpi     temp1, HIGH(RPM_TO_COMM_TIME(RPM_START_MIN_RPM)*4*CLK_SCALE) 
0002fd 9100 0064                 lds     temp1, timing_x
0002ff e010                      ldi     temp2, BYTE3(RPM_TO_COMM_TIME(RPM_START_MIN_RPM)*4*CLK_SCALE) 
000300 0701                      cpc     temp1, temp2
000301 f010                      brcs    start_to_run
                 s6_start1:      
000302 df37                      rcall   start_timeout            
000303 cfc2                      rjmp    start1                  ; go back to state 1
                 
                 start_to_run:
000304 e208                      ldi     temp1, PWR_PCT_TO_VAL(PCT_PWR_MAX_STARTUP)
000305 2ed0                      mov     sys_control, temp1
000306 7f7d                      cbr     flags0, (1<<OCT1_MSB)
000307 def8                      rcall   calc_next_timing
000308 df0a                      rcall   wait_for_commutation    ; needed to align phases 
000309 df17                      rcall   wait_for_zc_blank       ; the ZC timeout should start at: ZC + comm_time + zc_blank_time
                 
                                 ;DbgLEDOff
                 
00030a 759f                      cbr     flags2, (1<<NO_SYNC) + (1<<STARTUP) 
00030b c000                      rjmp    run1                    ; running state begins
                                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** running control loop ****
                 
                 ; run 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 run1:           
00030c d07c                      rcall   wait_for_low
00030d ff70                      sbrs    flags0, OCT1_PENDING
00030e c003                      rjmp    run1_fail
00030f d08a                      rcall   wait_for_high
000310 fd70                      sbrc    flags0, OCT1_PENDING
000311 c007                      rjmp    run1_1
                 run1_fail:             
000312 fd97                      sbrc    flags2, NO_SYNC
000313 c067                      rjmp    run_to_start
000314 6890                      sbr     flags2, (1<<NO_SYNC) 
000315 df5c                      rcall   no_sync_poff
000316 d0d5                      rcall   com3com4
000317 decd                      rcall   correct_next_timing
000318 c029                      rjmp    run4
                 run1_1:                
000319 dee6                      rcall   calc_next_timing
00031a def8                      rcall   wait_for_commutation
00031b d0bb                      rcall   com1com2
00031c df04                      rcall   wait_for_zc_blank
00031d 779f                      cbr     flags2, (1<<NO_SYNC) 
                 ; run 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 run2:
00031e d07b                      rcall   wait_for_high
00031f ff70                      sbrs    flags0, OCT1_PENDING
000320 c003                      rjmp    run2_fail
000321 d067                      rcall   wait_for_low
000322 fd70                      sbrc    flags0, OCT1_PENDING
000323 c007                      rjmp    run2_1
                 run2_fail:
000324 fd97                      sbrc    flags2, NO_SYNC
000325 c055                      rjmp    run_to_start
000326 6890                      sbr     flags2, (1<<NO_SYNC) 
000327 df4a                      rcall   no_sync_poff
000328 d0ca                      rcall   com4com5
000329 debb                      rcall   correct_next_timing
00032a c029                      rjmp    run5
                 run2_1:                
00032b ded4                      rcall   calc_next_timing
00032c dee6                      rcall   wait_for_commutation
00032d d0b0                      rcall   com2com3
00032e def2                      rcall   wait_for_zc_blank
00032f 779f                      cbr     flags2, (1<<NO_SYNC) 
                 ; run 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
000330 d058      run3:           rcall   wait_for_low
000331 ff70                      sbrs    flags0, OCT1_PENDING
000332 c003                      rjmp    run3_fail
000333 d066                      rcall   wait_for_high
000334 fd70                      sbrc    flags0, OCT1_PENDING
000335 c007                      rjmp    run3_1
                                 
                 run3_fail:                
000336 fd97                      sbrc    flags2, NO_SYNC
000337 c043                      rjmp    run_to_start
000338 6890                      sbr     flags2, (1<<NO_SYNC) 
000339 df38                      rcall   no_sync_poff
00033a d0c6                      rcall   com5com6
00033b dea9                      rcall   correct_next_timing
00033c c029                      rjmp    run6
                 run3_1:                
00033d dec2                      rcall   calc_next_timing
00033e ded4                      rcall   wait_for_commutation
00033f d0ac                      rcall   com3com4
000340 dee0                      rcall   wait_for_zc_blank
000341 779f                      cbr     flags2, (1<<NO_SYNC) 
                 ; run 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
000342 d057      run4:           rcall   wait_for_high
000343 ff70                      sbrs    flags0, OCT1_PENDING
000344 c003                      rjmp    run4_fail
000345 d043                      rcall   wait_for_low
000346 fd70                      sbrc    flags0, OCT1_PENDING
000347 c007                      rjmp    run4_1
                 run4_fail:                
000348 fd97                      sbrc    flags2, NO_SYNC
000349 c031                      rjmp    run_to_start
00034a 6890                      sbr     flags2, (1<<NO_SYNC) 
00034b df26                      rcall   no_sync_poff
00034c d0bb                      rcall   com6com1
00034d de97                      rcall   correct_next_timing
00034e cfbd                      rjmp    run1
                 run4_1:        
00034f deb0                      rcall   calc_next_timing
000350 dec2                      rcall   wait_for_commutation
000351 d0a1                      rcall   com4com5
000352 dece                      rcall   wait_for_zc_blank
000353 779f                      cbr     flags2, (1<<NO_SYNC) 
                 ; run 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
000354 d034      run5:           rcall   wait_for_low
000355 ff70                      sbrs    flags0, OCT1_PENDING
000356 c003                      rjmp    run5_fail
000357 d042                      rcall   wait_for_high
000358 fd70                      sbrc    flags0, OCT1_PENDING
000359 c007                      rjmp    run5_1
                                 
                 run5_fail:                
00035a fd97                      sbrc    flags2, NO_SYNC
00035b c01f                      rjmp    run_to_start
00035c 6890                      sbr     flags2, (1<<NO_SYNC) 
00035d df14                      rcall   no_sync_poff
00035e d078                      rcall   com1com2
00035f de85                      rcall   correct_next_timing
000360 cfbd                      rjmp    run2
                 run5_1:                
000361 de9e                      rcall   calc_next_timing
000362 deb0                      rcall   wait_for_commutation
000363 d09d                      rcall   com5com6
000364 debc                      rcall   wait_for_zc_blank
000365 779f                      cbr     flags2, (1<<NO_SYNC) 
                 ; run 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
000366 d033      run6:           rcall   wait_for_high
000367 ff70                      sbrs    flags0, OCT1_PENDING
000368 c003                      rjmp    run6_fail
000369 d01f                      rcall   wait_for_low
00036a fd70                      sbrc    flags0, OCT1_PENDING
00036b c007                      rjmp    run6_1
                                 
                 run6_fail:                
00036c fd97                      sbrc    flags2, NO_SYNC
00036d c00d                      rjmp    run_to_start
00036e 6890                      sbr     flags2, (1<<NO_SYNC) 
00036f df02                      rcall   no_sync_poff
000370 d06d                      rcall   com2com3
000371 de73                      rcall   correct_next_timing
000372 cfbd                      rjmp    run3
                 run6_1:                
000373 de8c                      rcall   calc_next_timing
000374 de9e                      rcall   wait_for_commutation
000375 d092                      rcall   com6com1
000376 dd9f                      rcall   evaluate_sys_state 
000377 dea9                      rcall   wait_for_zc_blank
000378 779f                      cbr     flags2, (1<<NO_SYNC) 
                 run6_1_1:                
000379 fd94                      sbrc    flags2, RUN_MIN_RPM
00037a cf91                      rjmp    run1
                 
00037b 6290      run_to_start:   sbr     flags2, (1<<STARTUP)
00037c 32f8                      cpi     ZH, PWR_PCT_TO_VAL(PCT_PWR_MAX_STARTUP) 
00037d f008                      brcs    run_to_start_2
00037e c001                      rjmp    restart_control
                 run_to_start_2:                
00037f cf34                      rjmp    wait_for_power_on
                 
                 restart_control:
000380 94f8                      cli                             ; disable all interrupts
000381 dedc                      rcall   switch_power_off
000382 cc9b                      rjmp    reset
                 ;-----bko-----------------------------------------------------------------
                 ; *** scan comparator utilities ***
                 
                 #include "str_zc_filter.inc"
                 
                   #define STRT_ZC_FILTER_DELAY    33
                   #define STRT_ZC_FILTER_FACTOR   7
                 #elif(POWER_RANGE == 250)
                 #elif(POWER_RANGE == 125)
                 #elif(POWER_RANGE == 100)
                 #elif(POWER_RANGE == 50)
                 #endif
                 
                 filter_delay:  
000383 930f                      push    temp1
000384 e201                      ldi     temp1, STRT_ZC_FILTER_DELAY
                 filter_delay_loop: 
000385 950a                      dec     temp1
000386 f7f1                      brne    filter_delay_loop
000387 910f                      pop     temp1
000388 9508                      ret
                 
                 .macro __wait_for_filter
                                 clc
                                 sbis    ACSR, ACO
                                 sec
                                 in      temp5, SREG
                                 adc     temp2, temp6 
                                 out     SREG, temp5
                                 rol     temp1
                                 sbc     temp2, temp6
                 .endmacro
                                                 
                 wait_for_low:   
000389 ef0f                      ldi     temp1, 0xFF
00038a e018                      ldi     temp2, 8
00038b e022                      ldi     temp3, (8-ZCF_CONST) + 1
00038c 2444                      clr     temp6 
                 wait_for_low_loop:
00038d ff70                      sbrs    flags0, OCT1_PENDING
00038e 9508                      ret
00038f 9488
000390 9b45
000391 9408
000392 b63f
000393 1d14
000394 be3f
000395 1f00
000396 0914                      __wait_for_filter
000397 1712                      cp      temp2, temp3
000398 f7a0                      brcc    wait_for_low_loop
000399 9508                      ret
                                                
                 wait_for_high:   
00039a e000                      ldi     temp1, 0x0
00039b e010                      ldi     temp2, 0
00039c e027                      ldi     temp3, ZCF_CONST
00039d 2444                      clr     temp6 
                 wait_for_high_loop:
00039e ff70                      sbrs    flags0, OCT1_PENDING
00039f 9508                      ret
0003a0 9488
0003a1 9b45
0003a2 9408
0003a3 b63f
0003a4 1d14
0003a5 be3f
0003a6 1f00
0003a7 0914                      __wait_for_filter
0003a8 1712                      cp      temp2, temp3
0003a9 f3a0                      brcs    wait_for_high_loop
0003aa 9508                      ret
                 
                 wait_for_high_strt:
0003ab e000                      ldi     temp1, 0x0
0003ac e010                      ldi     temp2, 0
0003ad e027                      ldi     temp3, STRT_ZC_FILTER_FACTOR
0003ae 2444                      clr     temp6 
                                 
                 wait_for_high_strt_loop2:                
0003af ff84                      sbrs    flags1, PWM_OFF_CYCLE
0003b0 cffe                      rjmp    wait_for_high_strt_loop2
                                 
                 wait_for_high_strt_loop:
0003b1 ff70                      sbrs    flags0, OCT1_PENDING
0003b2 9508                      ret
0003b3 9488
0003b4 9b45
0003b5 9408
0003b6 b63f
0003b7 1d14
0003b8 be3f
0003b9 1f00
0003ba 0914                      __wait_for_filter
0003bb dfc7                      rcall   filter_delay
0003bc 1712                      cp      temp2, temp3
0003bd f398                      brcs    wait_for_high_strt_loop
0003be 9508                      ret
                 
                 wait_for_low_strt:
0003bf ef0f                      ldi     temp1, 0xFF
0003c0 e018                      ldi     temp2, 8
0003c1 e022                      ldi     temp3, (8-STRT_ZC_FILTER_FACTOR) + 1
0003c2 2444                      clr     temp6 
                                 
                 wait_for_low_strt_loop2:
0003c3 ff84                      sbrs    flags1, PWM_OFF_CYCLE
0003c4 cffe                      rjmp    wait_for_low_strt_loop2
                                 
                 wait_for_low_strt_loop:
0003c5 ff70                      sbrs    flags0, OCT1_PENDING
0003c6 9508                      ret
0003c7 9488
0003c8 9b45
0003c9 9408
0003ca b63f
0003cb 1d14
0003cc be3f
0003cd 1f00
0003ce 0914                      __wait_for_filter
0003cf dfb3                      rcall   filter_delay
0003d0 1712                      cp      temp2, temp3
0003d1 f798                      brcc    wait_for_low_strt_loop
0003d2 9508                      ret
                                 
                 wait_for_test:
0003d3 ff70                      sbrs    flags0, OCT1_PENDING
0003d4 9508                      ret
0003d5 cffd                      rjmp    wait_for_test
0003d6 9508                      ret
                                 
                 ;-----bko-----------------------------------------------------------------
                 ; *** commutation utilities ***
                 #ifdef HIGH_SIDE_PWM
                 #else
0003d7 98ad      com1com2:       BpFET_off                             ; Bp off
0003d8 98ab                      CpFET_off                             ; Cp off
0003d9 ff80                      sbrs    flags1, POWER_OFF
0003da 9a94                      ApFET_on                              ; Ap on
0003db e007
0003dc b907                      AcPhaseB
0003dd 9508                      ret
                 com2com3:       
0003de 94f8                      PwmCSEnter
0003df 98ab                      CpFET_off
0003e0 7c77                      cbr     flags0, (1<<A_FET) + (1<<B_FET) + (1<<C_FET)   
0003e1 6078                      sbr     flags0, (1<<B_FET)            ; next nFET = BnFET
0003e2 fd82                      sbrc    flags1, NO_COMM               ; 
0003e3 c004                      rjmp    c2_done                       ; .. yes - futhermore work is done in timer0 interrupt
0003e4 98c0                      CnFET_off                             ; Cn off
0003e5 9895                      AnFET_off                             ; An off
0003e6 ff80                      sbrs    flags1, POWER_OFF
0003e7 9aac                      BnFET_on                              ; Bn on
                 c2_done:        
0003e8 9478                      PwmCSLeave
0003e9 e000
0003ea b907                      AcPhaseC
0003eb 9508                      ret
                 
0003ec 9894      com3com4:       ApFET_off                             ; Ap off
0003ed 98ad                      BpFET_off                             ; Bp off
0003ee ff80                      sbrs    flags1, POWER_OFF
0003ef 9aab                      CpFET_on                              ; Cp on
0003f0 e006
0003f1 b907                      AcPhaseA
0003f2 9508                      ret
                 
                 com4com5:       
0003f3 94f8                      PwmCSEnter 
0003f4 98ad                      BpFET_off
0003f5 7c77                      cbr     flags0, (1<<A_FET) + (1<<B_FET) + (1<<C_FET)   
0003f6 6270                      sbr     flags0, (1<<A_FET)            ; next nFET = AnFET
0003f7 fd82                      sbrc    flags1, NO_COMM               ; 
0003f8 c004                      rjmp    c4_done                       ; .. yes - futhermore work is done in timer0 interrupt
0003f9 98ac                      BnFET_off                             ; Bn off
0003fa 98c0                      CnFET_off                             ; Cn off
0003fb ff80                      sbrs    flags1, POWER_OFF
0003fc 9a95                      AnFET_on                              ; An on
                 c4_done:        
0003fd 9478                      PwmCSLeave
0003fe e007
0003ff b907                      AcPhaseB
000400 9508                      ret
                 
000401 98ab      com5com6:       CpFET_off                             ; Cp off
000402 9894                      ApFET_off                             ; Ap off
000403 ff80                      sbrs    flags1, POWER_OFF
000404 9aad                      BpFET_on                              ; Bp on
000405 e000
000406 b907                      AcPhaseC
000407 9508                      ret
                 
                 com6com1:       
000408 94f8                      PwmCSEnter
000409 9894                      ApFET_off
00040a 7c77                      cbr     flags0, (1<<A_FET) + (1<<B_FET) + (1<<C_FET)   
00040b 6170                      sbr     flags0, (1<<C_FET)            ; next nFET = CnFET
00040c fd82                      sbrc    flags1, NO_COMM               ; 
00040d c004                      rjmp    c6_done                       ; .. yes - futhermore work is done in timer0 interrupt
00040e 9895                      AnFET_off                             ; An off
00040f 98ac                      BnFET_off                             ; Bn off
000410 ff80                      sbrs    flags1, POWER_OFF
000411 9ac0                      CnFET_on                              ; Cn on
                 c6_done:        
000412 9478                      PwmCSLeave
000413 e006
000414 b907                      AcPhaseA
000415 9508                      ret
                 
                 #endif                
                 
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8 register use summary:
r0 :   0 r1 :  12 r2 :   0 r3 :  26 r4 :  36 r5 :   0 r6 :   2 r7 :   4 
r8 :   3 r9 :   3 r10:   8 r11:   8 r12:   4 r13:  12 r14:   6 r15:   0 
r16: 193 r17:  78 r18:  42 r19:  34 r20:  10 r21:   6 r22:  12 r23:  50 
r24:  30 r25:  38 r26:   2 r27:   1 r28:  32 r29:  32 r30:   3 r31:   8 
x  :   1 y  :   0 z  :   0 
Registers used: 29 out of 35 (82.9%)

ATmega8 instruction use summary:
adc   :  14 add   :   9 adiw  :   0 and   :   0 andi  :   0 asr   :   0 
bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :  11 brcs  :  15 
breq  :   6 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 
brlo  :   3 brlt  :   0 brmi  :   0 brne  :  16 brpl  :   0 brsh  :   2 
brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 
cbi   :  25 cbr   :  26 clc   :   4 clh   :   0 cli   :  12 cln   :   0 
clr   :  22 cls   :   0 clt   :   0 clv   :   0 clz   :   0 com   :   9 
cp    :  12 cpc   :  13 cpi   :  23 cpse  :   0 dec   :  12 eor   :   0 
fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  19 
inc   :   2 ld    :   0 ldd   :   0 ldi   : 105 lds   :  28 lpm   :   0 
lsl   :   1 lsr   :   9 mov   :  28 movw  :   6 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   8 or    :   0 ori   :   0 out   :  62 
pop   :  13 push  :  13 rcall : 131 ret   :  39 reti  :  22 rjmp  :  63 
rol   :   5 ror   :  13 sbc   :   8 sbci  :   4 sbi   :  13 sbic  :   0 
sbis  :   5 sbiw  :   0 sbr   :  33 sbrc  :  28 sbrs  :  29 sec   :   4 
seh   :   0 sei   :  12 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   :  26 sub   :   3 subi  :   7 swap  :   0 tst   :   7 wdr   :   0 

Instructions used: 50 out of 108 (46.3%)

ATmega8 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00082c   2070     22   2092    8192  25.5%
[.dseg] 0x000060 0x0000d6      0    118    118    1024  11.5%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
